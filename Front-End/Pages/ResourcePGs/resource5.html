<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--Bootstrap Link-->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
    <!--Stylesheet -->
    <link rel="stylesheet" href="resource.css">
    <title>Document</title>
</head>
<body>
<main>
    <div class="container">
        <h2>How to flatten JSON Data using pandas.</h2>by Jane Cooper
        <p>It is now quite popular to store semi-structured information using JSON format. Indeed, JSON files have quite
            simple structure and can be easily read by human beings. JSON syntax allows one to represent complex
            dependencies in data and avoid data duplication. Moreover, all modern programming languages have
            libraries<br>
            that facilitate JSON parsing and storing data into this format. Not surprisingly, JSON is extensively used
            to return data in Application Programming Interfaces (APIs) .
        </p>
        <p>At the same time, data analysts prefer to deal with structured data represented in the form of series and
            dataframes. Unfortunately, transforming JSON data into structured format is not that straightforward. To
            parse one type of JSON file may see you writing 40 lines of code, an approach which isn`t really
            scalable.</p>
        <p>
        <h5>Flattening JSON using pandas</h5>
        If you have limited time, it is better to make use of pandas’s json_normalize function. This function is rarely
        used by data analysts. That’s why I decide to write this article.
        The function, which uses json_normalize and achieves the result equivalent to the one considered in the previous
        section, is the following:

        </p>
        <p>Although it is only 10 lines smaller, it is much easier to read. There, only two actions are performed:
            json_normalize was used to read and normalize json data, and rename function to rename the columns of the
            dataframe. The usage of the latter is not necessary but allows us to have the same column names as in the
            previous section.
        </p>
        <p>Let us consider json_normalize function parameters closer. The first parameter json_data is a dictionary
            representation of json data.</p>
        <p>The second parameter record_path specifies the path to the record data (usually, this is the data important
            for the analysis). Each piece of this data will become a separate row in the final dataframe. For instance,
            in our function we specify that the record data should be taken from matches -> segments.</p>
        <p>The meta list enumerates all the contextual fields, data from which should appear in columns in the final
            dataframe. Note that if you want to include data from some internal fields, you need to specify the full
            path to them in the form of list (e.g., ). For instance, in our case if we want to have a column with
            reference UID data, we need to add ['matches', 'uid'] to the meta parameter list. Then, in the final
            dataframe, we would get a column which name would consist of these parts separated by . by default (you can
            change the separator using sep parameter).</p>
        <p>Media type entries have different set of context fields. The third parameter, errors (equal to ignore), asks
            the json_normalize function to ignore errors if some fields are not found.</p>
        <p>Then, we use pandas’s rename function to rename columns in the final dataframe.<br>

            Source: Yury Zhauniarovich</p>
    </div>

</main>
</body>
</html>